# Task ID: 3
# Title: Data Models and Error Handling
# Status: pending
# Dependencies: 1
# Priority: high
# Description: Implement the User data model, request/response schemas, and error handling framework
# Details:
1. Create the User model in src/models/user.rs:
```rust
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub struct User {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Deserialize, Validate)]
pub struct CreateUserRequest {
    #[validate(length(min = 1, max = 255))]
    pub name: String,
    #[validate(email)]
    pub email: String,
}

#[derive(Debug, Deserialize, Validate)]
pub struct UpdateUserRequest {
    #[validate(length(min = 1, max = 255))]
    pub name: Option<String>,
    #[validate(email)]
    pub email: Option<String>,
}
```

2. Create error handling framework in src/error.rs:
```rust
use axum::{response::{IntoResponse, Response}, http::StatusCode, Json};
use serde::Serialize;
use thiserror::Error;

#[derive(Debug, Error)]
pub enum ApiError {
    #[error("Validation error: {0}")]
    Validation(String),
    
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),
    
    #[error("Resource not found")]
    NotFound,
    
    #[error("Internal server error")]
    InternalServerError,
}

#[derive(Serialize)]
pub struct ErrorResponse {
    pub error: String,
    pub message: String,
}

impl IntoResponse for ApiError {
    fn into_response(self) -> Response {
        let (status, error_response) = match self {
            ApiError::Validation(msg) => (
                StatusCode::BAD_REQUEST,
                ErrorResponse {
                    error: "VALIDATION_ERROR".to_string(),
                    message: msg,
                },
            ),
            ApiError::NotFound => (
                StatusCode::NOT_FOUND,
                ErrorResponse {
                    error: "NOT_FOUND".to_string(),
                    message: "Resource not found".to_string(),
                },
            ),
            ApiError::Database(e) => {
                tracing::error!("Database error: {:?}", e);
                (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    ErrorResponse {
                        error: "DATABASE_ERROR".to_string(),
                        message: "A database error occurred".to_string(),
                    },
                )
            },
            ApiError::InternalServerError => (
                StatusCode::INTERNAL_SERVER_ERROR,
                ErrorResponse {
                    error: "INTERNAL_ERROR".to_string(),
                    message: "An internal error occurred".to_string(),
                },
            ),
        };

        (status, Json(error_response)).into_response()
    }
}

pub type Result<T> = std::result::Result<T, ApiError>;
```

3. Create a validation utility in src/models/validation.rs:
```rust
use validator::{Validate, ValidationErrors};
use crate::error::ApiError;

pub fn validate_request<T: Validate>(request: &T) -> Result<(), ApiError> {
    request.validate().map_err(|e: ValidationErrors| {
        let message = e.to_string();
        ApiError::Validation(message)
    })
}
```

4. Add the validator crate to Cargo.toml:
```toml
validator = { version = "0.16", features = ["derive"] }
```

5. Create a mod.rs file in src/models/ to export the models:
```rust
pub mod user;
pub mod validation;

pub use user::{User, CreateUserRequest, UpdateUserRequest};
```

# Test Strategy:
1. Write unit tests for the User model serialization/deserialization:
```rust
#[test]
fn test_user_serialization() {
    let user = User {
        id: 1,
        name: "Test User".to_string(),
        email: "test@example.com".to_string(),
        created_at: Utc::now(),
        updated_at: Utc::now(),
    };
    
    let json = serde_json::to_string(&user).unwrap();
    let deserialized: User = serde_json::from_str(&json).unwrap();
    
    assert_eq!(user.id, deserialized.id);
    assert_eq!(user.name, deserialized.name);
    assert_eq!(user.email, deserialized.email);
}
```

2. Test validation logic with valid and invalid inputs:
```rust
#[test]
fn test_user_validation() {
    // Valid request
    let valid_req = CreateUserRequest {
        name: "Test User".to_string(),
        email: "test@example.com".to_string(),
    };
    assert!(validate_request(&valid_req).is_ok());
    
    // Invalid email
    let invalid_email = CreateUserRequest {
        name: "Test User".to_string(),
        email: "invalid-email".to_string(),
    };
    assert!(validate_request(&invalid_email).is_err());
    
    // Empty name
    let empty_name = CreateUserRequest {
        name: "".to_string(),
        email: "test@example.com".to_string(),
    };
    assert!(validate_request(&empty_name).is_err());
}
```

3. Test error response formatting:
```rust
#[test]
fn test_error_response() {
    let error = ApiError::NotFound;
    let response = error.into_response();
    assert_eq!(response.status(), StatusCode::NOT_FOUND);
    
    let error = ApiError::Validation("Invalid email".to_string());
    let response = error.into_response();
    assert_eq!(response.status(), StatusCode::BAD_REQUEST);
}
```
